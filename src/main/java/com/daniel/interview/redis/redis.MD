#缓存 + 过期时间的策略来提高接口访问速度,减少了后端负载,同时保证数据刷新

##缓存穿透
    指用户查询数据,在数据库没有,自然在缓存中也不会有。这样就导致用户查询的时候,在缓存中找不到,每次都要去数据库再查询一遍,
    然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库,这也是经常提的缓存命中率问题。

##缓存穿透解决方案
    1.缓存空值。 –缓存太多空值,占用更多空间。（优化：给个空值过期时间） –存储层更新代码后,后台设置时主动删除空值,并缓存把值进去;
    2.将数据库中所有的查询条件,放到布隆过滤器中。当一个查询请求来临的时候,先经过布隆过滤器进行检查,如果请求存在这个条件中,那么继续执行,
    如果不在,直接丢弃。如果一个查询返回的数据为空（不管是数据不存在,还是系统故障）,仍然把这个空结果进行缓存,但过期时间会很短,通过这个直接设置的默认值存放到缓存,
    这样第二次到缓存中获取就有值了,而不会继续访问数据库,这种办法最简单粗暴！

##缓存雪崩（缓存失效）
    由于原有缓存失效,新缓存未到期间(例如：设置缓存时采用了相同的过期时间,将会在同一时刻出现大面积的缓存过期),所有原本应该访问缓存的请求都去查询数据库了,
    对数据库CPU和内存造成巨大压力,严重的会造成数据库宕机。从而形成一系列连锁反应,造成整个系统崩溃

##缓存雪崩的解决方案
    1.在缓存失效后,通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key同一时刻只允许一个线程查询数据和写缓存,其他线程等待,
    这种方案只是为了减轻数据库的压力,并没有提高系统吞吐量,因此,在真正的高并发场景下很少使用
    2.给每一项缓存数据增加相应的缓存标记,记录缓存的是否失效,如果缓存标记失效,则更新数据缓存。
    其中,缓存标记：记录缓存数据是否过期,如果过期触发另外的线程在后台去更新实际key的缓存;缓存数据：它的过期时间比缓存标记的时间延长1倍,
    例：标记缓存时间30分钟,数据缓存设置为60分钟。 这样,当缓存标记key过期后,实际缓存还能把旧数据返回给调用端,直到另外的线程在后台更新完成后,才会返回新缓存
    3.不同的key,设置不同的过期时间,让缓存失效的时间点尽量均匀

 ##缓存预热
    提前将相关的缓存数据加载到缓存系统
    1.数据量不大,可以在项目启动的时候自动进行加载；
    2.定时刷新缓存
    
##缓存更新
    除缓存服务器自带的缓存失效策略之外（Redis默认6种策略）,常见的策略有
    1.定时清理过期的缓存
    2.当有请求过来时,判断这个请求所用到的缓存是否过期,过期就去底层系统得到新数据并更新缓存
    1缺点是维护大量缓存的key比较麻烦;2缺点是每次用户请求过来都要判断缓存失效,逻辑相对复杂

###缓存降级
    降级的最终目的是保证核心服务可用,即使是有损的。但有些服务是无法降级的（如加入购物车、结算）;对系统进行梳理,看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护,哪些可降级

#Redis
##Redis的过期处理是针对key,即设置的是key的有效时间。Expires字典保存了所有键的过期时间
    expire key time(以秒为单位)--这是最常用的方式
    setex(String key, int seconds, String value)--字符串独有的方式
    
    如果没有设置时间,那缓存就是永不过期
    如果设置过期时间,又想让缓存永不过期,使用persist key
    
##Redis过期策略
    1.定时删除 设置key的过期时间的同时,为该key创建一个定时器,定时器在key到达过期时间时,删除key
        保证内存被尽快释放   若过期key很多,删除这些key会占用很多的CPU资源
    2.惰性删除
        删除操作只发生在从数据库取出key的时候发生
    3.定期删除 每隔一段时间执行一次删除(配置redis.conf 的hz选项,默认为10 即1秒执行10次,100ms一次,值越大说明刷新频率越快,最Redis性能损耗也越大,配置redis.conf的maxmemory最大值)过期key操作
    
    
    